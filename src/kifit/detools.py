import numpy as np

from itertools import (
    product,
    combinations
)

from kifit.fitools import generate_paramsamples

# keys for saving / reading data
##############################################################################

det_keys = [
    "elem",
    "gkp",
    "dim",
    "alphas",
    "sigalphas",
    "npermutations",
    "minpos",
    "maxneg",
    "allpos",
    "allneg",
    "nsigmas",
    "x_ind"
]


# generate samples
##############################################################################

def generate_Xindep_dets(
    elem,
    messenger,
    dim,
    gkp=True
):
    """
    Using the determinant formula specified by the dim and gkp arguments,
    generate mean & uncertainties of the numerator (voldat) and of the part of
    the denominator (vol1) that is independent of the X-coefficients.

    Args:
        elem:          element of interest (instance of the Elem class)
        messenger:     specifies run configuration (instance of Config class)
        dim (int):     dimension of determinant
        gkp (boolean): if True, the formula associated with the generalised King
                       plot is used, else, that of the no-mass generalised King
                       plot is used.

    Returns:
        meanvoldat:    mean values for numerator (voldat),
                       (np.array of dimension (number of data permutations, ))
        sigvoldat:     uncertainty on meanvoldat
                       (np.array of same dimension as meanvoldat)

        meanvol1:      mean values of contributions to denominator (vol1)
                       (np.array of dimension (number of data permutations,
                       number of non-zero entries in appropriate Levi-Civita
                       tensor))
        sigvol1:       uncertainties on meanvol1
                       (np.array of same dimension as meanvol1)
        xindlist:      list of indices of X-coefficients to be multiplied with
                       contributions to vol1
                       list of length = number of non-zero entries in
                       appropriate Levi-Civita tensor
    """

    nsamples = messenger.params.num_det_samples

    elemparamsamples = generate_paramsamples(
        elem.means_input_params, elem.stdevs_input_params, nsamples
    )

    voldatsamples = []
    vol1samples = []

    for s, paramsample in enumerate(elemparamsamples):
        elem._update_elem_params(paramsample)

        if gkp:
            alphaNPparts = elem.alphaNP_GKP_part(dim)
        else:
            alphaNPparts = elem.alphaNP_NMGKP_part(dim)

        voldatsamples.append(alphaNPparts[0])
        vol1samples.append(alphaNPparts[1])
        if s == 0:
            xindlist = alphaNPparts[2]
        else:
            assert xindlist == alphaNPparts[2], (xindlist, alphaNPparts[2])

    # voldatsamples has the form [sample][alphaNP-permutation]
    # vol1samples has the form [sample][alphaNP-permutation][eps-term]

    # for each term, average over all samples.

    meanvoldat = np.average(np.array(voldatsamples), axis=0)  # [permutation]
    sigvoldat = np.std(np.array(voldatsamples), axis=0)

    meanvol1 = np.average(np.array(vol1samples), axis=0)  # [perm][eps-term]
    sigvol1 = np.std(np.array(vol1samples), axis=0)

    return meanvoldat, sigvoldat, meanvol1, sigvol1, xindlist


def assemble_alphaNP(
    elem,
    meanvoldat,
    sigvoldat,
    meanvol1,
    sigvol1,
    xindlist,
    xind,
    dim,
    gkp
):
    """
    Assemble alphaNP and sigma[alphaNP] from X-independent parts generated by
    generate_Xindep_dets and appropriate X-coefficients.

    Args:
        elem:            Element of interest (instance of Elem class)
        meanvoldat:      mean numerator (computed by generate_Xindep_dets)
        sigvoldat:       std numerator
        meanvol1:        means of X-independent parts of denominator
        sigvol1:         std X-independent parts of denominator
        xindlist (list): list of indices specifying which X-coefficients are to
                         be multiplied with the elements of vol1
        xind (int):      index of X-coefficients for which alphaNP is to be
                         computed (corresponds to fixed value of mphi)
        dim (int):       dimension of determinant
        gkp (boolean):   if True, generalised King plot formula, else no-mass
                         generalised King plot formula is used

    Returns:
        alphaNPs:        assembled alphaNP values
                         (np.array of dimension (number of data permutations, ))
        sigalphaNPs:     uncertainties on alphaNPs
                         (np.array of same dimensions as alphaNPs)

    """

    alphaNPs = []
    sigalphaNPs = []

    elem._update_Xcoeffs(xind)

    """ p: alphaNP-permutation index and xpinds: X-indices for sample p"""
    alphaNP_p_list = []
    sig_alphaNP_p_list = []

    for p, xpinds in enumerate(xindlist):
        meanvol1_p = np.array([elem.Xvec[xp] for xp in xpinds]) @ (meanvol1[p])
        sigvol1_p_sq = np.array([elem.Xvec[xp] ** 2 for xp in xpinds]) @ (
            sigvol1[p] ** 2
        )

        alphaNP_p_list.append(meanvoldat[p] / meanvol1_p)
        sig_alphaNP_p_list.append(
            (sigvoldat[p] / meanvol1_p) ** 2
            + (meanvoldat[p] / meanvol1_p**2) ** 2 * sigvol1_p_sq
        )

    alphaNPs = np.math.factorial(dim - 2) * np.array(alphaNP_p_list)
    sigalphaNPs = np.math.factorial(dim - 2) * np.array(sig_alphaNP_p_list)

    return alphaNPs, sigalphaNPs


def generate_alphaNP_det_samples(
    elem,
    messenger,
    dim,
    gkp=True,
    xind=0
):
    """
    Generate Get a set of ``nsamples`` of alphaNP by varying the masses and isotope
    shifts according to the means and standard deviations given in the input
    files:

       m  ~ N(<m>,  sig[m])
       m' ~ N(<m'>, sig[m'])
       v  ~ N(<v>,  sig[v])

    For each of these samples and for all possible combinations of the data,
    compute alphaNP using the Generalised King Plot formula with

        (nisotopepairs, ntransitions) = (dim, dim-1).

    Args:
        elem:          element of interest (instance of Elem class)
        messenger:     specifies run configuration (instance of Config class)
        dim (int):     dimension of (no-mass-) generalised King plot to be used
        gkp (boolean): if True, generalised King plot is computed, else no-mass
                       generalised King plot
    Returns:
        alphaNPs:      np.array of shape (lenp, ), with lenp (cf. below)
        sigalphas:     np.array of shape (lenp, ), with lenp (cf. below)
        lenp (int):    number of data permutations

    """
    # Part independent of X-coeffs
    meanvoldat, sigvoldat, meanvol1, sigvol1, xindlist = generate_Xindep_dets(
        elem=elem,
        messenger=messenger,
        dim=dim,
        gkp=gkp)

    # Part with X-coeffs

    alphaNPs, sigalphaNPs = assemble_alphaNP(
        elem=elem,
        meanvoldat=meanvoldat,
        sigvoldat=sigvoldat,
        meanvol1=meanvol1,
        sigvol1=sigvol1,
        xindlist=xindlist,
        xind=xind,
        dim=dim,
        gkp=gkp)

    # check dimensions

    if gkp:
        lenp = len(list(
            product(
                combinations(elem.range_a, dim),
                combinations(elem.range_i, dim - 1))))

    else:
        lenp = len(list(
            product(
                combinations(elem.range_a, dim),
                combinations(elem.range_i, dim))))

    assert alphaNPs.shape[0] == lenp
    assert sigalphaNPs.shape[0] == lenp

    return alphaNPs, sigalphaNPs, lenp


# determine bounds
##############################################################################

def get_minpos_maxneg_alphaNP_bounds(alphaNPs, sigalphaNPs, nsigmas=2):
    """
    Determine smallest positive and largest negative values for the bound on
    alphaNP at the desired confidence level.

    all vectors have dimensions [x][perm]

    """
    alphaNPs = np.array(alphaNPs)  # [x][perm]
    sigalphaNPs = np.array(sigalphaNPs)  # [x][perm]

    assert all(sigalphaNPs > 0)

    alphaNP_UB = alphaNPs + nsigmas * sigalphaNPs
    alphaNP_LB = alphaNPs - nsigmas * sigalphaNPs

    allpos = np.where(alphaNP_UB > 0, alphaNP_UB, np.nan)
    allneg = np.where(alphaNP_LB < 0, alphaNP_LB, np.nan)

    minpos = np.nanmin(allpos)
    maxneg = np.nanmax(allneg)

    return minpos, maxneg, allpos, allneg


# det procedure
##############################################################################

def sample_alphaNP_det(
    elem,
    messenger,
    dim,
    gkp,
    xind=0
):
    """
    Generate determinant results for elem specified by

    Args:
        elem:          element of interest (instance of the Elem class)
        messenger:     run configuration (instance of the Config class)
        dim (int):     dimension of the (no-mass-) generalised King plot
        gkp (boolean): specifying whether the generalised King plot formula is
                       to be used (alternative: no-mass generalised King plot)
        xind (int):    index of the X-coefficient for which the results are to
                       be computed

    Returns:
        det_results_x: list of determinant reults which are also written to the
                       det output file specified by messenger.
                       N.B.: This output should fit to the det_keys defined in
                       detools.py


    """

    alphas, sigalphas, nb_permutations = generate_alphaNP_det_samples(
        elem=elem,
        messenger=messenger,
        dim=dim,
        gkp=gkp,
        xind=xind)

    (
        minpos, maxneg, allpos, allneg
    ) = get_minpos_maxneg_alphaNP_bounds(alphas, sigalphas,
        messenger.params.num_sigmas)

    det_results_x = [
        elem.id,
        gkp,
        dim,
        alphas,
        sigalphas,
        nb_permutations,
        minpos,
        maxneg,
        allpos,
        allneg,
        messenger.params.num_sigmas,
        xind
    ]

    print("det_output[alphas].shape in sample_alphaNP_det", alphas.shape)
    print("alphas", alphas)

    messenger.paths.write_det_output(gkp, dim, xind, det_results_x)

    return det_results_x


# collect all data for mphi-vs-alphaNP plot
##############################################################################

def collect_det_X_data(config, dim, gkp):
    """
    Load all data produced in run specified by

    Args:
        messenger:     run configuration (instance of the Config class)
        dim (int):     dimension of the (no-mass-) generalised King plot
        gkp (boolean): indicates whether the generalised King plot formula is to
                       be used (alternative: no-mass generalised King plot

    ... and organise it in terms of the X-coefficients.

    Returns:
        a set of lists, each of which has the length of the mphi-vector
        specified in the files of X-coefficients.

        UB (np.array):     most stringent nsigma-upper bounds on alphaNP (with
                           nsigma specified in config)
        allpos (np.array): all positive nsigma-bounds on alphaNP
        LB (np.array):     most stringent nsigma-lower bounds on alphaNP
        allneg (np.array): all negative nsigma-bounds

    """
    alphas = []
    sigalphas = []
    UB = []
    allpos = []
    LB = []
    allneg = []

    for x in config.x_vals_det:

        det_output = config.paths.read_det_output(gkp, dim, x)

        lenp = det_output["npermutations"]

        alphas.append(det_output["alphas"])
        sigalphas.append(det_output["sigalphas"])
        UB.append(det_output["minpos"])
        allpos.append(det_output["allpos"])
        LB.append(det_output["maxneg"])
        allneg.append(det_output["allneg"])

    alphas = np.array(alphas).reshape(len(config.x_vals_det), lenp)
    sigalphas = np.array(sigalphas).reshape(len(config.x_vals_det), lenp)

    allpos = np.array(allpos).reshape(len(config.x_vals_det), lenp)
    allneg = np.array(allneg).reshape(len(config.x_vals_det), lenp)

    UB = np.array(UB).reshape(len(config.x_vals_det))
    LB = np.array(LB).reshape(len(config.x_vals_det))

    return (alphas, sigalphas,
            UB, allpos, LB, allneg)
